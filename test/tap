#!/usr/bin/env node

const path = require('path')
const Piscina = require('piscina')
const fs = require('fs')
const os = require('os')

const prefix = 'npm_config_'
const valid = {
  sentence_case: ['on+guess', 'on', 'off'],
  case_protection: [ 'as-needed', 'strict', 'off' ],
  section: [ 'export', 'import', 'merge', 'other' ],
}
const config = Object.assign({
  sentence_case: valid.sentence_case.slice(0, 1),
  case_protection: valid.case_protection.slice(0, 1),
  section: valid.section,
  test: '',
  snapshot: '',
  unabbreviations: path.resolve(path.join(__dirname, '..', 'unabbrev.json')),
  strings: path.resolve(path.join(__dirname, '..', 'strings.bib')),
}, require('./tap.json'))
if (process.env.CI === 'true') config.big = []

for (let [option, value] of Object.entries(process.env)) {
  if (!option.startsWith(prefix)) continue

  option = option.substr(prefix.length)

  let err
  if (valid[option]) {
    value = value.split('\n\n')
    if (err = value.find(v => !valid[option].includes(v))) {
      throw new Error(`Invalid value ${JSON.stringify(err)} for ${option}`)
    }
  }
  else if (typeof config[option] === 'undefined') {
    continue
  }
  else if (option === 'big' || option === 'exception') {
    value = []
  }
  config[option] = value
}

if (config.snapshot) { // reset to all for snapshots
  for (const [key, value] of Object.entries(valid)) {
    if (!process.env[prefix + key]) config[key] = value
  }
}

if (config.snapshot) process.env.TAP_SNAPSHOT = '1'

// require *after* setting TAP_SNAPSHOT
const tap = require('tap')
tap.jobs = os.cpus().length - 1

function isTestcase(bibfile) {
  if (!bibfile.replace(/(la)?tex$/, '').endsWith('.bib')) return false
  if (config.big.includes(path.basename(bibfile))) return false
  if (config.test && !bibfile.includes(config.test)) return false
  return true
}

const piscina = new Piscina({ filename: path.resolve(__dirname, 'worker') })

for (const sentence_case of config.sentence_case) {
  for (const case_protection of config.case_protection) {
    for (const section of config.section) {
      let root = path.join(__dirname, section === 'other' ? '' : 'better-bibtex', section)

      for (let bibfile of fs.readdirSync(root)) {
        bibfile = path.join(root, bibfile)
        if (!isTestcase(bibfile)) continue

        const basename = path.basename(bibfile)
        const unabbreviate = config.unabbreviate.includes(basename);

        ((bibfile, options, name, snapshot) => {
          tap.test(name, async t => {
            t.snapshotFile = snapshot
            t.matchSnapshot(await piscina.run({ bibfile, options }))
          })
        })(
          bibfile,
          {
            caseProtection: case_protection === 'off' ? false : case_protection,
            sentenceCase: sentence_case.startsWith('on'),
            guessAlreadySentenceCased: sentence_case.endsWith('guess'),
            unabbreviations: unabbreviate && config.unabbreviations,
            strings: unabbreviate && config.strings,
            exception: config.exception.includes(basename),
            raw: config.raw.includes(basename),
            // Oh Mendeley....
            verbatimFields: config.mendeley.includes(basename) ? bibtex.fields.verbatim.filter(field => !field.startsWith('file')) : undefined
          },
          `${section}=${basename}`,
          path.resolve(__dirname, 'tap-snapshots', `${sentence_case}^${case_protection}`, section, basename + '.snap')
        )
      }
    }
  }
}
