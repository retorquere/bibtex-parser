#!/usr/bin/env node

const path = require('path')
const Piscina = require('piscina')
const fs = require('fs')
const os = require('os')
const glob = require('glob').sync

const prefix = 'npm_config_'
const valid = {
  sentence_case: ['on+guess', 'on', 'off'],
  case_protection: [ 'as-needed', 'strict', 'off' ],
}
const multi = ['test']

const config = Object.assign({
  sentence_case: valid.sentence_case.slice(0, 1),
  case_protection: valid.case_protection.slice(0, 1),
  test: [''],
  snapshot: '',
  unabbreviations: path.resolve(path.join(__dirname, '..', 'unabbrev.json')),
  strings: path.resolve(path.join(__dirname, '..', 'strings.bib')),
}, require('./tap.json'))
if (process.env.CI === 'true') config.big = []

for (let [option, value] of Object.entries(process.env)) {
  if (!option.startsWith(prefix)) continue

  option = option.substr(prefix.length)

  let err
  if (valid[option] || multi.includes(option)) {
    value = value.split('\n\n')
    if (valid[option] && (err = value.find(v => !valid[option].includes(v)))) {
      throw new Error(`Invalid value ${JSON.stringify(err)} for ${option}`)
    }
  }
  else if (typeof config[option] === 'undefined') {
    continue
  }
  else if (option === 'big' || option === 'exception') {
    value = []
  }
  config[option] = value
}

if (config.snapshot) { // reset to all for snapshots
  for (const [key, value] of Object.entries(valid)) {
    if (!process.env[prefix + key]) config[key] = value
  }
  config.big = []
}
if (config.test.length !== 1 || config.test[0] !== '') config.big=[] // if you pick out a test, you want it ran

if (config.snapshot) process.env.TAP_SNAPSHOT = '1'
console.log(config)

// require *after* setting TAP_SNAPSHOT
const tap = require('tap')
tap.jobs = os.cpus().length - 1

const piscina = new Piscina({ filename: path.resolve(__dirname, 'worker') })

function testcases(pattern) {
  return glob(path.join(__dirname, '**', config.test[0] + '*.{bib,bibtex,biblatex}'), { nocase: true, matchBase: true, nonull: false, nodir: true })
}

for (const sentence_case of config.sentence_case) {
  for (const case_protection of config.case_protection) {
    for (const pattern of config.test) {
      for (const bibfile of testcases(pattern)) {
        const basename = path.basename(bibfile)
        if (config.big.includes(basename)) continue

        const section = path.basename(path.dirname(bibfile))
        const unabbreviate = config.unabbreviate.includes(basename);

        ((bibfile, options, name, snapshot) => {
          tap.test(name, async t => {
            const result = await piscina.run({ bibfile, options })
            if (typeof result !== 'string' && result.errors.length && !config.error.includes(path.basename(bibfile))) throw JSON.stringify(result.errors[0], null, 2)
            t.snapshotFile = snapshot
            t.matchSnapshot(await piscina.run({ bibfile, options }))
          })
        })(
          bibfile,
          {
            caseProtection: case_protection === 'off' ? false : case_protection,
            sentenceCase: sentence_case.startsWith('on'),
            guessAlreadySentenceCased: sentence_case.endsWith('guess'),
            unabbreviations: unabbreviate && config.unabbreviations,
            strings: unabbreviate && config.strings,
            exception: config.exception.includes(basename),
            raw: config.raw.includes(basename),
            // Oh Mendeley....
            verbatimFields: config.mendeley.includes(basename) ? bibtex.fields.verbatim.filter(field => !field.startsWith('file')) : undefined
          },
          `${section}=${basename}`,
          path.resolve(__dirname, 'tap-snapshots', `${sentence_case}^${case_protection}`, section, basename + '.snap')
        )
      }
    }
  }
}
