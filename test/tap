#!/usr/bin/env node

const { Worker, isMainThread, parentPort, workerData } = require('worker_threads')

if (isMainThread) {
  const fs = require('fs')
  const path = require('path')
  const os = require('os')

  const prefix = 'npm_config_'
  const valid = {
    sentence_case: ['on+guess', 'on', 'off'],
    case_protection: [ 'as-needed', 'strict', 'off' ],
    section: [ 'export', 'import', 'merge', 'other' ],
  }
  const config = {
    sentence_case: valid.sentence_case[0],
    case_protection: valid.case_protection[0],
    section: valid.section,
    test: '',
    big: process.env.CI === 'true' ? [] : require('./tap.json').big,
    exception: require('./tap.json').exception,
    snapshot: '',
  }

  for (let [option, value] of Object.entries(process.env)) {
    if (!option.startsWith(prefix)) continue

    option = option.substr(prefix.length)

    let err
    if (valid[option]) {
      value = value.split('\n\n')
      if (err = value.find(v => !valid[option].includes(v))) {
        throw new Error(`Invalid value ${JSON.stringify(err)} for ${option}`)
      }
    }
    else if (typeof config[option] === 'undefined') {
      continue
    }
    else if (option === 'big' || option === 'exception') {
      value = []
    }
    config[option] = value
  }

  if (config.snapshot) { // reset to all for snapshots
    for (const [key, value] of Object.entries(valid)) {
      if (!process.env[prefix + key]) config[key] = value
    }
  }

  if (config.snapshot) process.env.TAP_SNAPSHOT = '1'
  // require *after* setting TAP_SNAPSHOT
  const tap = require('tap')

  tap.jobs = os.cpus().length
  for (const section of config.section) {
    tap.test(`worker ${i}`, tap => {
      tap.plan(2)
      const worker = new Worker(__filename, { workerData: { ...config, section })
      worker.on('message', m => tap.same(m, { index: i }))
      worker.on('exit', code => t.equal(code, 0, 'exited successfully'))

            t.matchSnapshot(result)
    })
  }
}
else {

  const bibtex = require('../index')


if (!config.spawned) {
  (async () => {
    for (const section of config.section) {
      tap.spawn('npm', ['test', '--ignore-scripts', `--config=${JSON.stringify({...config, section, spawned: true})}`], null, section).finally(() => tap.end())
    }
  })()
  process.exit()
}

function isTestcase(bibfile) {
  if (!bibfile.replace(/(la)?tex$/, '').endsWith('.bib')) return false
  if (config.big.includes(path.basename(bibfile))) return false
  if (config.test && !bibfile.includes(config.test)) return false
  return true
}

for (const sentence_case of config.sentence_case) {
  for (const case_protection of config.case_protection) {
    for (const section of config.section) {
      let root = path.join(__dirname, section === 'other' ? '' : 'better-bibtex', section)

      for (const bibfile of fs.readdirSync(root)) {
        if (!isTestcase(bibfile)) continue

        (test => {
          const basename = path.basename(test.bibfile)
          tap.test(`${test.section}=${basename}`, { buffered: true }, async t => {
            const unabbreviate = test.bibfile.toLowerCase().includes('unabbreviate')
            const options = {
              caseProtection: test.case_protection === 'off' ? false : test.case_protection,
              sentenceCase: test.sentence_case.startsWith('on'),
              guessAlreadySentenceCased: test.sentence_case.endsWith('guess'),
              unabbreviations: unabbreviate ? path.resolve(path.join(__dirname, '..', 'unabbrev.json')) : false,
              strings: unabbreviate ? path.resolve(path.join(__dirname, '..', 'strings.bib')) : false,
            }
            if (test.bibfile.includes('-raw.bib')) options.raw = true
            // Oh Mendeley....
            if (basename.startsWith('Async')) options.verbatimFields = bibtex.fields.verbatim.filter(field => !field.startsWith('file'))

            const source = await fs.promises.readFile(test.bibfile, 'utf-8')
            let result
            if (config.exception.includes(basename)) {
              await bibtex.promises.parse(source, {...options, errorHandler: err => { result = `caught error: ${err.message}` } })
            }
            else {
              result = await bibtex.promises.parse(source, options)
            }

            t.snapshotFile = path.resolve(__dirname, 'tap-snapshots', `${test.sentence_case}^${test.case_protection}`, test.section, basename + '.snap')
            t.matchSnapshot(result)
            t.end()
          })
        })({
          bibfile: path.join(root, bibfile),
          sentence_case,
          case_protection,
          section,
        })
      }
    }
  }
}
