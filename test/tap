const fs = require('fs')
const path = require('path')
const bibtex = require('../index')

const valid = {
  sentence_case: ['on+guess', 'on', 'off'],
  case_protection: [ 'as-needed', 'strict', 'off' ],
}
const config = {
  sentence_case: valid.sentence_case[0],
  case_protection: valid.case_protection[0],
  test: '',
  big: process.env.CI === 'true' ? [] : [
    'Async import, large library #720.bib',
    'Really Big whopping library.bibtex',
    'long.bib',
    'Cache does not seem to fill #1296.bibtex',
    'Unabbreviate on import #1436-2.bib',
    'Unabbreviate on import #1436-3.bib',
  ],
  exception: [
    'unknown command handler #1733.bib',
    'web_page and other mendeley idiocy.bib',
  ],
  snapshot: '',
}

const prefix = 'npm_config_'
for (let [option, value] of Object.entries(process.env)) {
  if (!option.startsWith(prefix)) continue

  option = option.substr(prefix.length)

  let err
  if (valid[option]) {
    value = value.split('\n\n')
    if (err = value.find(v => !valid[option].includes(v))) {
      throw new Error(`Invalid value ${JSON.stringify(err)} for ${option}`)
    }
  }
  else if (typeof config[option] === 'undefined') {
    continue
  }
  else if (option === 'big' || option === 'exception') {
    value = []
  }
  config[option] = value
}
if (config.snapshot) {
  process.env.TAP_SNAPSHOT = '1'
  for (const [key, value] of Object.entries(valid)) {
    if (!process.env[prefix + key]) config[key] = value
  }
}

// require *after* setting TAP_SNAPSHOT
const tap = require('tap')

function isTestcase(bibfile) {
  if (!bibfile.replace(/(la)?tex$/, '').endsWith('.bib')) return false
  if (config.big.includes(path.basename(bibfile))) return false
  if (config.test && !bibfile.includes(config.test)) return false
  return true
}

for (const sentence_case of config.sentence_case) {
  for (const case_protection of config.case_protection) {
    for (const section of ['other', 'export', 'import', 'merge']) {
      let root = path.join(__dirname, section === 'other' ? '' : 'better-bibtex', section)

      for (const bibfile of fs.readdirSync(root)) {
        if (!isTestcase(bibfile)) continue

        (test => {
          const basename = path.basename(test.bibfile)
          tap.test(`${test.section}=${basename}`, { buffered: true }, async t => {
            const unabbreviate = test.bibfile.toLowerCase().includes('unabbreviate')
            const options = {
              caseProtection: test.case_protection === 'off' ? false : test.case_protection,
              sentenceCase: test.sentence_case.startsWith('on'),
              guessAlreadySentenceCased: test.sentence_case.endsWith('guess'),
              unabbreviations: unabbreviate ? path.resolve(path.join(__dirname, '..', 'unabbrev.json')) : false,
              strings: unabbreviate ? path.resolve(path.join(__dirname, '..', 'strings.bib')) : false,
            }
            if (test.bibfile.includes('-raw.bib')) options.raw = true
            // Oh Mendeley....
            if (basename.startsWith('Async')) options.verbatimFields = bibtex.fields.verbatim.filter(field => !field.startsWith('file'))

            const source = await fs.promises.readFile(test.bibfile, 'utf-8')
            let result
            if (config.exception.includes(basename)) {
              await bibtex.promises.parse(source, {...options, errorHandler: err => { result = `caught error: ${err.message}` } })
            }
            else {
              result = await bibtex.promises.parse(source, options)
            }

            t.snapshotFile = path.resolve(__dirname, 'tap-snapshots', `${test.sentence_case}^${test.case_protection}`, test.section, basename + '.snap')
            t.matchSnapshot(result)
          })
        })({
          bibfile: path.join(root, bibfile),
          sentence_case,
          case_protection,
          section,
        })
      }
    }
  }
}
